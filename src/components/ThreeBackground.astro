---
// Three.js 3D 背景组件 - 创建动态几何体背景
---

<div id="three-container" class="fixed top-0 left-0 w-full h-full pointer-events-none -z-10"></div>

<script>
  import * as THREE from 'three';

  class ThreeBackground {
    private scene: THREE.Scene;
    private camera: THREE.PerspectiveCamera;
    private renderer: THREE.WebGLRenderer;
    private geometries: THREE.Mesh[] = [];
    private mouseX: number = 0;
    private mouseY: number = 0;

    constructor() {
      this.scene = new THREE.Scene();
      this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      
      this.init();
    }

    init() {
      // 设置渲染器
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      
      const container = document.getElementById('three-container');
      if (container) {
        container.appendChild(this.renderer.domElement);
      }

      // 相机位置
      this.camera.position.z = 30;

      // 创建几何体
      this.createGeometries();

      // 添加光源
      this.addLights();

      // 事件监听
      window.addEventListener('resize', () => this.onResize());
      document.addEventListener('mousemove', (e) => {
        this.mouseX = (e.clientX / window.innerWidth) * 2 - 1;
        this.mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
      });

      this.animate();
    }

    createGeometries() {
      // 判断是否为移动设备，减少几何体数量以优化性能
      const isMobile = window.innerWidth < 768;
      const geometryCount = isMobile ? 8 : 20;
      
      // 创建漂浮的几何体
      const geometryTypes = [
        new THREE.IcosahedronGeometry(1, 0),
        new THREE.OctahedronGeometry(1, 0),
        new THREE.TetrahedronGeometry(1, 0),
        new THREE.TorusGeometry(0.5, 0.2, 16, 100),
        new THREE.DodecahedronGeometry(0.8, 0),
      ];

      for (let i = 0; i < geometryCount; i++) {
        const geometry = geometryTypes[Math.floor(Math.random() * geometryTypes.length)];
        
        const material = new THREE.MeshPhongMaterial({
          color: new THREE.Color().setHSL(Math.random() * 0.3 + 0.7, 0.5, 0.5),
          transparent: true,
          opacity: 0.3,
          wireframe: Math.random() > 0.5,
          side: THREE.DoubleSide,
        });

        const mesh = new THREE.Mesh(geometry, material);
        
        // 随机位置
        mesh.position.x = (Math.random() - 0.5) * 50;
        mesh.position.y = (Math.random() - 0.5) * 50;
        mesh.position.z = (Math.random() - 0.5) * 30 - 10;
        
        // 随机旋转速度
        mesh.userData = {
          rotationSpeed: {
            x: (Math.random() - 0.5) * 0.01,
            y: (Math.random() - 0.5) * 0.01,
            z: (Math.random() - 0.5) * 0.01,
          },
          floatSpeed: Math.random() * 0.02 + 0.01,
          floatOffset: Math.random() * Math.PI * 2,
        };

        this.geometries.push(mesh);
        this.scene.add(mesh);
      }

      // 添加星空粒子
      this.createStars();
    }

    createStars() {
      // 判断是否为移动设备，减少星星数量
      const isMobile = window.innerWidth < 768;
      const starCount = isMobile ? 200 : 500;
      
      const starGeometry = new THREE.BufferGeometry();
      const positions = new Float32Array(starCount * 3);

      for (let i = 0; i < starCount * 3; i += 3) {
        positions[i] = (Math.random() - 0.5) * 100;
        positions[i + 1] = (Math.random() - 0.5) * 100;
        positions[i + 2] = (Math.random() - 0.5) * 100;
      }

      starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

      const starMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.1,
        transparent: true,
        opacity: 0.8,
      });

      const stars = new THREE.Points(starGeometry, starMaterial);
      this.scene.add(stars);
    }

    addLights() {
      // 环境光
      const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
      this.scene.add(ambientLight);

      // 点光源
      const pointLight1 = new THREE.PointLight(0xa855f7, 1, 100);
      pointLight1.position.set(10, 10, 10);
      this.scene.add(pointLight1);

      const pointLight2 = new THREE.PointLight(0x3b82f6, 1, 100);
      pointLight2.position.set(-10, -10, 10);
      this.scene.add(pointLight2);
    }

    onResize() {
      this.camera.aspect = window.innerWidth / window.innerHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
    }

    animate() {
      requestAnimationFrame(() => this.animate());

      const time = Date.now() * 0.001;

      // 更新几何体
      this.geometries.forEach((mesh) => {
        const { rotationSpeed, floatSpeed, floatOffset } = mesh.userData;
        
        mesh.rotation.x += rotationSpeed.x;
        mesh.rotation.y += rotationSpeed.y;
        mesh.rotation.z += rotationSpeed.z;
        
        // 浮动效果
        mesh.position.y += Math.sin(time * floatSpeed + floatOffset) * 0.01;
      });

      // 相机跟随鼠标
      this.camera.position.x += (this.mouseX * 5 - this.camera.position.x) * 0.05;
      this.camera.position.y += (this.mouseY * 5 - this.camera.position.y) * 0.05;
      this.camera.lookAt(this.scene.position);

      this.renderer.render(this.scene, this.camera);
    }
  }

  // 初始化 Three.js 背景
  if (typeof window !== 'undefined') {
    new ThreeBackground();
  }
</script>
